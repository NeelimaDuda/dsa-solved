Arrays/Hashing

1. Two Sum

import java.util.*;
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> s=new HashMap<>();
        for(int i=0;i<nums.length;i++)
        {
            int j=target-nums[i];
            if(s.containsKey(j)) 
            {
            return new int[] {s.get(j),i};
            
            }
            else 
            {
                s.put(nums[i],i);}

        }
        return new int[0];
    }
    
}
__________________________________________________________
242. Valid Anagram

class Solution {
    public boolean isAnagram(String s, String t) {
        if (s.length()!=t.length())
        {
            return false;
        }
        int[] a=new int[26];
        for(int i=0;i<s.length();i++)
        {
            a[s.charAt(i)-'a']++;
        }
        for(int i=0;i<t.length();i++)
        {
            a[t.charAt(i)-'a']--;
        }
        for(int i:a)
        {
            if (i!=0) return false;
        }
        return true;

    }
}
______________________________________________________________
217. Contains Duplicate

import java.util.Set;
class Solution {
    public boolean containsDuplicate(int[] nums) {
        //Set<Integer> s=new HashSet<>();
        Set<Integer> s=Arrays.stream(nums).boxed().collect(Collectors.toSet());
        if(nums.length==s.size()) return false;
        return true;

    }
}
__________________________________________________________________

49. Group Anagrams

O(n^2) approach
class Solution {
    public List<List<String>> groupAnagrams(String[] strs1) {
        List<List<String>> ls=new ArrayList<List<String>>();
        ArrayList<String> strs=Arrays.stream(strs1).collect(Collectors.toCollection(ArrayList::new));
        for(int k=0;k<strs.size();k++)
        {
            List<String> temp=new ArrayList<>();
            String i=strs.get(k);
            temp.add(i);
            int[] a =new int[26];
            for(int j=0;j<i.length();j++)
            {
                a[i.charAt(j)-97]++;
            }
            for(int m=k+1;m<strs.size();m++)
            {
                int[] b =new int[26];
                String i2=strs.get(m);
                for(int j=0;j<i2.length();j++)
            {
                b[i2.charAt(j)-97]++;
            }
            if(Arrays.equals(a,b))
            {
                temp.add(i2);
                strs.remove(m);
                m--;
            }
            }
            ls.add(temp);
        }
        return ls;
    }
}
______________________________________________
O(n)

Here you are using a HashMap and key will the Arrays.toString(int[])
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {

        Map<String, List<String>> map = new HashMap<>();

        for (String s : strs) {
            int[] freq = new int[26];
            for (char c : s.toCharArray()) {
                freq[c - 'a']++;
            }

            String key = Arrays.toString(freq);

            map.computeIfAbsent(key, ArrayList::new).add(s);
        }

        return new ArrayList<>(map.values());
    }
}
________________________________________________________________________

347. Top K Frequent Elements

class Solution {
    public int[] topKFrequent(int[] nums, int k) {
        //Creating a hashmap
        int n=nums.length;
        HashMap<Integer,Integer> h=new HashMap<>();
        for(int i:nums)
        { 
            int ki=i;
            h.put(ki,h.getOrDefault(ki,0)+1);
        }

        //create buckets
        List<Integer>[] bucket=new ArrayList[n+1]; //Considering indices as freq
        for(Map.Entry<Integer,Integer> e:h.entrySet())
        {
            
            int ind=e.getValue();
            if(bucket[ind]==null )
            {
                bucket[ind]=new ArrayList<>();
            }
            bucket[ind].add(e.getKey());
        }

        //retrieve
        int[] r=new int[k];
        int in=0;
        for(int i=bucket.length-1;i>=0 && in<k;i-- )
        { 
            if(bucket[i]!=null)
            {
                for(int num:bucket[i])
                {
                    r[in]=num;
                    in++;
                    if(in==k) break;
                }
            }
        }
        return r;

    
    }
}
___________________________________________________________________

238. Product of Array Except Self

18/24 test cases passed, Time limit exceeded
class Solution {
    public int[] productExceptSelf(int[] nums) {
        ArrayList<Integer> arr = Arrays.stream(nums).boxed().collect(Collectors.toCollection(ArrayList::new));
        for(int i=0;i<nums.length;i++)
        {
            arr.remove(i);
            int p=arr.stream().mapToInt(Integer::intValue).
            reduce(1,(a,b)->a*b);
            arr.add(i,nums[i]);
            nums[i]=p;   
        }
        return nums;
    }
}
_____________

Optimal O(n)
class Solution {
    public int[] productExceptSelf(int[] nums) {
        int n=nums.length;
        int[] la=new int[n];
            la[0]=1;
        for(int i=1;i<nums.length;i++)
        {
            la[i]=la[i-1]*nums[i-1];
        }
        int r=1;
        for(int i=n-1;i>=0;i--)
        {
            la[i]=r*la[i];
            r=r*nums[i];
        }
    return la;
    }
}
_________________________________________________________________________

36. Valid Sudoku

class Solution {
    public boolean isValidSudoku(char[][] board) {
        HashSet<Character> h = new HashSet<>();
        h.add('1');
        h.add('2');
        h.add('3');
        h.add('4');
        h.add('5');
        h.add('6');
        h.add('7');
        h.add('8');
        h.add('9');
        int flag = 0;

        for (int i = 0; i < 9; i++) {
            HashSet<Character> hsr = new HashSet<>();
            HashSet<Character> hsc = new HashSet<>();
            HashSet<Character> box = new HashSet<>();

            int countr = 0;
            for (int j = 0; j < 9; j++) {
                char c = board[i][j];
                if (h.contains(c)) {
                    hsr.add(c);
                    countr++;
                }
            }
            int countc = 0;
            for (int j = 0; j < 9; j++) {
                char c = board[j][i];
                if (h.contains(c)) {
                    hsc.add(c);
                    countc++;
                }
            }
            int rowStart = (i / 3) * 3;
            int colStart = (i % 3) * 3;

            int countb = 0;
            for (int r = rowStart; r < rowStart + 3; r++) {
                for (int c = colStart; c < colStart + 3; c++) {
                    char ch = board[r][c];
                    if (h.contains(ch)) {
                        box.add(ch);
                        countb++;
                    }
                }
            }

            if (hsr.size() != countr || hsc.size() != countc || box.size() != countb) {
                flag = 1;
                break;
            }
        }
        if (flag == 1)
            return false;
        return true;

    }

}
__________________________________________________________________________________________
128. Longest Consecutive Sequence

class Solution {
    public int longestConsecutive(int[] nums) {
        if(nums.length==0||nums==null) return 0;
        HashSet<Integer> hs=new HashSet<>();
        for(int i:nums)
        {
            hs.add(i);
        }
        int len=0;

        for(int i:hs)
        {
            
            if(!hs.contains(i-1))
            {
                int current=i;
                int l=1; 
                
            
            while(hs.contains(current+1))
            {
            current=current+1;
                l++;
            }
            len=Math.max(l,len); 
            //System.out.println(len);
        }
        }
        return len;   
    }
}

_______________________________________________________
167.Two Sum II
 
class Solution {
    public int[] twoSum(int[] numbers, int target) {
        int left=0;
        int right=numbers.length-1;
        while(left<right)
        {
            int sum=numbers[left]+numbers[right];
            if(sum==target) return new int[]{left+1,right+1};
            else if (sum>target)
            {
                right--;
            }
            else left++;
        }
       return new int[]{};
    }
}

___________________________________________________________

15. 3Sum
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> res=new ArrayList<>();
        Arrays.sort(nums);
        for(int i=0;i<nums.length-2;i++)
        {
            if(i>0 && nums[i]==nums[i-1]) continue;
        

        int left=i+1;
        int right=nums.length-1;
        while(left<right)
        {
            int sum=nums[i]+nums[left]+nums[right];
            if(sum==0)
            {
                res.add(Arrays.asList(nums[i],nums[left],nums[right]));
            
            while(left<right && nums[left]==nums[left+1]) left++;
            while(left<right && nums[right]==nums[right-1]) right--;

            left++;
            right--;

        }
        else if(sum<0)
        left++;
        else right--;
        
        }
        }
        
        return res;
    }
}


_______________________________________________________________
423. Reconstruct Original Digits from English


class Solution {
    public String originalDigits(String s) {
        StringBuilder sb=new StringBuilder();
        //find count of each char
        int[] count=new int[26];
        for(char c:s.toCharArray())
        {
            count[c-'a']++;
        }
        int[] digit=new int[10];
        //finding unique digits 0,2,4,6,8
        
        digit[0] = count['z' - 'a']; // zero
        digit[2] = count['w' - 'a']; // two
        digit[4] = count['u' - 'a']; // four
        digit[6] = count['x' - 'a']; // six
        digit[8] = count['g' - 'a']; // eight

        digit[3]=count['h' - 'a']-digit[8];
        digit[5] = count['f' - 'a'] - digit[4];
        digit[7] = count['s' - 'a'] - digit[6];

        digit[1] = count['o' - 'a'] - digit[0] - digit[2] - digit[4];
        digit[9] = count['i' - 'a'] - digit[5] - digit[6] - digit[8];

        for(int i=0;i<10;i++)
        {
            while(digit[i]>0)
            {
                sb=sb.append(i);
                digit[i]--;
            }
        }
        return sb.toString();
  
    }
}



















